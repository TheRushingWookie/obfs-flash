#!/usr/bin/python

import os
import sys
import time

from collections import namedtuple
from functools import partial

from pyptlib.util import parse_addr_spec
from pyptlib.util.subproc import auto_killall, Popen, SINK
from pyptlib.client import ClientTransportPlugin

from subprocess import PIPE

from twisted.internet.defer import Deferred, DeferredList
from twisted.internet.stdio import StandardIO
from twisted.internet.protocol import Factory
from twisted.internet.endpoints import TCP4ClientEndpoint
from twisted.protocols.basic import LineReceiver
from twisted.protocols.portforward import ProxyServer as _ProxyServer
from twisted.python import log
from txsocksx.client import SOCKS4ClientEndpoint

PT_METHOD_NAME = "obfs3_flash"

def pt_child_env(managed_ver, env=os.environ):
    """
    Prepare the environment for a child PT process, by clearing all TOR_PT_*
    envvars except TOR_PT_STATE_LOCATION and TOR_PT_MANAGED_TRANSPORT_VER.
    """
    exempt = ['TOR_PT_STATE_LOCATION']
    cur_env = [(k, v) for k, v in env.iteritems()
                      if not k.startswith('TOR_PT_') or k in exempt]
    cur_env.append(('TOR_PT_MANAGED_TRANSPORT_VER', ','.join(managed_ver)))
    return cur_env

class CMethod(namedtuple('MethodSpec', 'name protocol addrport args opts')):
    @classmethod
    def fromLine(cls, line):
        args = line.rstrip('\n').split(' ')
        name = args[0]
        protocol = args[1]
        addrport = parse_addr_spec(args[2])
        args = args[3][-5:].split(',') if len(args) > 3 and args[3].startswith("ARGS=") else []
        opts = args[4][-9:].split(',') if len(args) > 4 and args[4].startswith("OPT-ARGS=") else []
        return CMethod(name, protocol, addrport, args, opts)

def branch(parent):
    """
    Returns a new Deferred that does not advance the callback-chain of the parent.

    See http://xph.us/2009/12/10/asynchronous-programming-in-python.html for motivation.
    """
    d = Deferred()
    parent.addCallback(lambda v: (v, d.callback(v))[0])
    parent.addErrback(lambda f: (f, d.errback(f))[1])
    return d

class ManagedTransportProtocolV1(LineReceiver):
    """
    A Twisted IProtocol to read PT output.

    See pt-spec.txt and others for details of the protocol.
    """
    # TODO(infinity0): eventually this could be padded out and moved to pyptlib

    delimiter = os.linesep
    protocol_version = "1"

    def __init__(self):
        self.cmethods = {}
        self._dCMethodsDone = Deferred()
        self._dPluginError = Deferred()
        # dPluginError triggers errors on all sub-events, not the other way round
        # so fatal sub-events should call _abort rather than errback on their Deferreds
        self._dPluginError.addErrback(lambda f: (f, self._fireCMethodsDone().errback(f))[0])
        # TODO(infinity0): call _abort if we don't recv CMETHODS DONE within n sec

    def whenCMethodsDone(self):
        """
        Return a new Deferred that calls-back when CMETHODS DONE is received.
        """
        return branch(self._dCMethodsDone)

    def whenPluginError(self):
        """
        Return a new Deferred that errors-back when the remote plugin fails.

        Note: the success chain (callback) is never fired.
        """
        return branch(self._dPluginError)

    def lineReceived(self, line):
        if not line: return

        (kw, args) = line.split(' ', 1)
        if kw == "VERSION":
            version = args.strip()
            if version != self.protocol_version:
                self._abort(ValueError("child used unsupported managed transport version: %s" % version))
        elif kw == "CMETHOD":
            cmethod = CMethod.fromLine(args)
            self.cmethods[cmethod.name] = cmethod
        elif kw == "CMETHODS" and args == "DONE":
            self._fireCMethodsDone().callback(self.cmethods)
        else:
            pass # ignore unrecognised line

    def connectionLost(self, reason):
        self._firePluginError().errback(reason)

    def _abort(self, exc):
        self._firePluginError().errback(exc)
        self.transport.loseConnection()

    def _fireCMethodsDone(self):
        """Return dCMethodsDone or a dummy if it was already called."""
        if self._dCMethodsDone:
            d = self._dCMethodsDone
            self._dCMethodsDone = None
            return d
        return Deferred()

    def _firePluginError(self):
        """Return dPluginError or a dummy if it was already called."""
        if self._dPluginError:
            d = self._dPluginError
            self._dPluginError = None
            return d
        return Deferred()

# TODO(infinity0): remove this class when twisted update their side
class ProxyServer(_ProxyServer):

    def connectionMade(self):
        # code copied from super class, except instead of connecting
        # to a TCP endpoint we abstract that out to a child method
        self.transport.pauseProducing()

        client = self.clientProtocolFactory()
        client.setServer(self)

        if self.reactor is None:
            from twisted.internet import reactor
            self.reactor = reactor

        self.connectProxyClient(client)

    def connectProxyClient(self, client):
        raise NotImplementedError()

class SOCKS4Wrapper(ProxyServer):

    def connectProxyClient(self, client):
        TCPPoint = TCP4ClientEndpoint(
            self.reactor,
            self.factory.local_host,
            self.factory.local_port)
        SOCKSPoint = SOCKS4ClientEndpoint(
            self.factory.remote_host,
            self.factory.remote_port,
            TCPPoint)
        d = SOCKSPoint.connect(client)
        @d.addErrback
        def _gotError(error):
            log.err(error, "error connecting to SOCKS server")

class SOCKS4WrapperFactory(Factory):
    protocol = SOCKS4Wrapper

    def __init__(self, local_host, local_port, remote_host, remote_port):
        self.local_host = local_host
        self.local_port = local_port
        self.remote_host = remote_host
        self.remote_port = remote_port

def pt_launch_child(reactor, client, methodnames, cmdline):
    """Launch a child PT and ensure it has the right transport methods."""
    cur_env = pt_child_env(ManagedTransportProtocolV1.protocol_version)
    sub_proc = Popen(cmdline,
        stdout = PIPE,
        env = dict(cur_env + {
            "TOR_PT_CLIENT_TRANSPORTS": ",".join(methodnames),
        }.items()),
        )
    sub_protocol = ManagedTransportProtocolV1()
    StandardIO(sub_protocol, stdin=sub_proc.stdout.fileno(), reactor=reactor)
    methoddefers = [sub_protocol.whenCMethodsDone().addCallback(
                        partial(pt_require_child, client, name))
                    for name in methodnames]
    return sub_proc, sub_protocol, methoddefers

def pt_require_child(client, childmethod, cmethods):
    """Callback for checking a child PT has the right transport methods."""
    if childmethod not in cmethods:
        client.reportMethodError(PT_METHOD_NAME, "failed to start required child transport: %s" % childmethod)
        raise ValueError()
    return cmethods[childmethod]

def obfs3_flash(reactor, client, fp_local, fp_remote, obfs_out):
    """
    Set up the obfs3_flash combined PT.

    :param twisted.internet.interfaces.IReactor reactor: Reactor to install this PT to.
    :param pyptlib.client.ClientTransportPlugin client: PT client API.
    :param int fp_local: Listen port for outgoing flashproxy connections.
    :param int fp_remote: Listen port for incoming flashproxy connections.
    :param int obfs_out: Listen port for obfsproxy to connect to.
    """
    ob_client = os.getenv("OBFSPROXY", "obfsproxy")
    fp_client = os.getenv("FLASHPROXY_CLIENT", "flashproxy-client")

    # start fp and ensure that it launches OK
    fp_proc, fp_prot, fp_defer = pt_launch_child(reactor, client,
        ["websocket"], [fp_client, ":%s" % fp_local, ":%s" % fp_remote])

    # shim to wrap obfs plain output to SOCKS input for flashproxy
    reactor.listenTCP(interface='127.0.0.1', port=obfs_out, factory=
        SOCKS4WrapperFactory('127.0.0.1', fp_local, '0.0.1.0', 1))

    # start ob and ensure that it launches OK
    ob_proc, ob_prot, ob_defer = pt_launch_child(reactor, client,
        ["obfs3"], [ob_client, "managed"])

    whenAllDone = DeferredList(fp_defer + ob_defer, consumeErrors=True)
    def allDone(success_list):
        success = all(r[0] for r in success_list)
        # failure was already reported by pt_require_child
        if success:
            ob_result = [r[1] for r in success_list if r[1].name == "obfs3"][0]
            # now report success of the overall composed PT
            client.reportMethodSuccess(PT_METHOD_NAME, ob_result.protocol, ob_result.addrport)
            client.reportMethodsEnd()
    whenAllDone.addCallback(allDone)

def main(*args):
    # config
    fp_local = int(os.getenv("FLASHPROXY_LOCAL_PORT", 9001))
    fp_remote = int(os.getenv("FLASHPROXY_REMOTE_PORT", 9000))
    obfs_out = 2334

    # runtime state
    client = ClientTransportPlugin()
    client.init([PT_METHOD_NAME])
    if not client.getServedTransports():
        print >>sys.stderr, "no transports to serve"
        return 1

    from twisted.internet import reactor
    auto_killall(1, cleanup=lambda:reactor.stop())
    obfs3_flash(reactor, client, fp_local, fp_remote, obfs_out)
    reactor.run(installSignalHandlers=0)
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
