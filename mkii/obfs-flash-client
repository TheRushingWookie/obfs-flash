#!/usr/bin/python

import os
import sys
import time

from collections import namedtuple
from functools import partial

from pyptlib.util import parse_addr_spec
from pyptlib.util.subproc import auto_killall, Popen, SINK
from pyptlib.client import ClientTransportPlugin

from subprocess import PIPE

from twisted.internet.defer import Deferred, DeferredList
from twisted.internet.stdio import StandardIO
from twisted.internet.protocol import Factory
from twisted.internet.endpoints import TCP4ClientEndpoint
from twisted.protocols.basic import LineReceiver
from twisted.protocols.portforward import ProxyServer as _ProxyServer
from twisted.python import log
from txsocksx.client import SOCKS4ClientEndpoint

PT_METHOD_NAME = "obfs3_flash"

def pt_child_env(managed_ver, env=os.environ):
    """
    Prepare the environment for a child PT process, by clearing all TOR_PT_*
    envvars except TOR_PT_STATE_LOCATION and TOR_PT_MANAGED_TRANSPORT_VER.
    """
    exempt = ['TOR_PT_STATE_LOCATION']
    cur_env = [(k, v) for k, v in env.iteritems()
                      if not k.startswith('TOR_PT_') or k in exempt]
    cur_env.append(('TOR_PT_MANAGED_TRANSPORT_VER', ','.join(managed_ver)))
    return cur_env

class CMethod(namedtuple('MethodSpec', 'name protocol addrport args opts')):
    pass

class ManagedTransportProtocolV1(LineReceiver):
    """
    A Twisted IProtocol to read PT output.

    See pt-spec.txt and others for details of the protocol.
    """
    # TODO(infinity0): eventually this could be padded out and moved to pyptlib

    delimiter = os.linesep
    protocol_version = "1"

    def __init__(self):
        self.cmethods = {}
        self.dCmethodsDone = Deferred()

    def whenCmethodsDone(self):
        d = Deferred()
        self.dCmethodsDone.addCallback(lambda v: (d.callback(v), v)[1])
        return d

    def lineReceived(self, line):
        if not line: return

        (kw, args) = line.split(' ', 1)
        if kw == "VERSION":
            pass
        elif kw == "CMETHOD":
            cmethod = self.parseMethods(*args.split(' '))
            self.cmethods[cmethod.name] = cmethod
        elif kw == "CMETHODS" and args == "DONE":
            self.dCmethodsDone.callback(self.cmethods)
        else:
            pass # ignore unrecognised line

    def parseMethods(self, *args):
        name = args[0]
        protocol = args[1]
        addrport = parse_addr_spec(args[2])
        args = args[3][-5:].split(',') if len(args) > 3 and args[3].startswith("ARGS=") else []
        opts = args[4][-9:].split(',') if len(args) > 4 and args[4].startswith("OPT-ARGS=") else []
        return CMethod(name, protocol, addrport, args, opts)

# TODO(infinity0): remove this class when twisted update their side
class ProxyServer(_ProxyServer):

    def connectionMade(self):
        # code copied from super class, except instead of connecting
        # to a TCP endpoint we abstract that out to a child method
        self.transport.pauseProducing()

        client = self.clientProtocolFactory()
        client.setServer(self)

        if self.reactor is None:
            from twisted.internet import reactor
            self.reactor = reactor

        self.connectProxyClient(client)

    def connectProxyClient(self, client):
        raise NotImplementedError()

class SOCKS4Wrapper(ProxyServer):

    def connectProxyClient(self, client):
        TCPPoint = TCP4ClientEndpoint(
            self.reactor,
            self.factory.local_host,
            self.factory.local_port)
        SOCKSPoint = SOCKS4ClientEndpoint(
            self.factory.remote_host,
            self.factory.remote_port,
            TCPPoint)
        d = SOCKSPoint.connect(client)
        @d.addErrback
        def _gotError(error):
            log.err(error, "error connecting to SOCKS server")

class SOCKS4WrapperFactory(Factory):
    protocol = SOCKS4Wrapper

    def __init__(self, local_host, local_port, remote_host, remote_port):
        self.local_host = local_host
        self.local_port = local_port
        self.remote_host = remote_host
        self.remote_port = remote_port

def pt_launch_child(reactor, client, methodnames, cmdline):
    """Launch a child PT and ensure it has the right transport methods."""
    cur_env = pt_child_env(ManagedTransportProtocolV1.protocol_version)
    sub_proc = Popen(cmdline,
        stdout = PIPE,
        env = dict(cur_env + {
            "TOR_PT_CLIENT_TRANSPORTS": ",".join(methodnames),
        }.items()),
        )
    sub_protocol = ManagedTransportProtocolV1()
    StandardIO(sub_protocol, stdin=sub_proc.stdout.fileno(), reactor=reactor)
    methoddefers = [sub_protocol.whenCmethodsDone().addCallback(
                        partial(pt_require_child, client, name))
                    for name in methodnames]
    return sub_proc, sub_protocol, methoddefers

def pt_require_child(client, childmethod, cmethods):
    """Callback for checking a child PT has the right transport methods."""
    if childmethod not in cmethods:
        client.reportMethodError(PT_METHOD_NAME, "failed to start required child transport: %s" % childmethod)
        raise ValueError()
    return cmethods[childmethod]

def obfs3_flash(reactor, client, fp_local, fp_remote, obfs_out):
    """
    Set up the obfs3_flash combined PT.

    :param twisted.internet.interfaces.IReactor reactor: Reactor to install this PT to.
    :param pyptlib.client.ClientTransportPlugin client: PT client API.
    :param int fp_local: Listen port for outgoing flashproxy connections.
    :param int fp_remote: Listen port for incoming flashproxy connections.
    :param int obfs_out: Listen port for obfsproxy to connect to.
    """
    ob_client = os.getenv("OBFSPROXY", "obfsproxy")
    fp_client = os.getenv("FLASHPROXY_CLIENT", "flashproxy-client")

    # start fp and ensure that it launches OK
    fp_proc, fp_prot, fp_defer = pt_launch_child(reactor, client,
        ["websocket"], [fp_client, ":%s" % fp_local, ":%s" % fp_remote])

    # shim to wrap obfs plain output to SOCKS input for flashproxy
    reactor.listenTCP(interface='127.0.0.1', port=obfs_out, factory=
        SOCKS4WrapperFactory('127.0.0.1', fp_local, '0.0.1.0', 1))

    # start ob and ensure that it launches OK
    ob_proc, ob_prot, ob_defer = pt_launch_child(reactor, client,
        ["obfs3"], [ob_client, "managed"])

    whenAllDone = DeferredList(fp_defer + ob_defer)
    def allDone(success_list):
        success = all(r[0] for r in success_list)
        # failure was already reported by pt_require_child
        if success:
            ob_result = [r[1] for r in success_list if r[1].name == "obfs3"][0]
            # now report success of the overall composed PT
            client.reportMethodSuccess(PT_METHOD_NAME, ob_result.protocol, ob_result.addrport)
            client.reportMethodsEnd()
    whenAllDone.addCallback(allDone)

def main(*args):
    # config
    fp_local = int(os.getenv("FLASHPROXY_LOCAL_PORT", 9001))
    fp_remote = int(os.getenv("FLASHPROXY_REMOTE_PORT", 9000))
    obfs_out = 2334

    # runtime state
    client = ClientTransportPlugin()
    client.init([PT_METHOD_NAME])
    if not client.getServedTransports():
        print >>sys.stderr, "no transports to serve"
        return 1

    from twisted.internet import reactor
    auto_killall(1, cleanup=lambda:reactor.stop())
    obfs3_flash(reactor, client, fp_local, fp_remote, obfs_out)
    reactor.run(installSignalHandlers=0)
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
