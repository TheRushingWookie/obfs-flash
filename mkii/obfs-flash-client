#!/usr/bin/python

import os
import sys
import time

from pyptlib.util.subproc import auto_killall, Popen, SINK
from pyptlib.client import ClientTransportPlugin

from subprocess import PIPE

from twisted.internet import stdio
from twisted.internet.protocol import Factory
from twisted.internet.endpoints import TCP4ClientEndpoint
from twisted.protocols.basic import LineReceiver
from twisted.protocols.portforward import ProxyServer as _ProxyServer
from twisted.python import log
from txsocksx.client import SOCKS4ClientEndpoint

def pt_child_env(env, managed_ver):
    """
    Prepare the environment for a child PT process, by clearing all TOR_PT_*
    envvars except TOR_PT_STATE_LOCATION and TOR_PT_MANAGED_TRANSPORT_VER.
    """
    exempt = ['TOR_PT_STATE_LOCATION']
    cur_env = [(k, v) for k, v in env.iteritems()
                      if not k.startswith('TOR_PT_') or k in exempt]
    cur_env.append(('TOR_PT_MANAGED_TRANSPORT_VER', ','.join(managed_ver)))
    return cur_env

class PTInterceptor(LineReceiver):
    """
    A Twisted IProtocol to read PT output.

    See pt-spec.txt and others for details of the protocol.

    Note: all output goes via the PT client rather than sendLine().
    """
    # TODO(infinity0): pad this out and move to pyptlib

    delimiter = os.linesep

    def __init__(self, client):
        self.client = client

    def lineReceived(self, line):
        if not line: return

        (kw, args) = line.split(" ", 1)
        if kw == "VERSION":
            pass
        elif kw == "CMETHOD" and args.startswith("obfs3 "):
            (_, socks, addrstr) = args.split(" ", 2)
            socksVer = socks[5:]
            addrport = addrstr.split(":")
            self.client.reportMethodSuccess("obfs3_flash", socksVer, addrport)
        elif kw == "CMETHODS" and args == "DONE":
            self.client.reportMethodsEnd()
        else:
            pass

# TODO(infinity0): remove this class when twisted update their side
class ProxyServer(_ProxyServer):

    def connectionMade(self):
        # code copied from super class, except instead of connecting
        # to a TCP endpoint we abstract that out to a child method
        self.transport.pauseProducing()

        client = self.clientProtocolFactory()
        client.setServer(self)

        if self.reactor is None:
            from twisted.internet import reactor
            self.reactor = reactor

        self.connectProxyClient(client)

    def connectProxyClient(self, client):
        raise NotImplementedError()

class SOCKS4Wrapper(ProxyServer):

    def connectProxyClient(self, client):
        TCPPoint = TCP4ClientEndpoint(
            self.reactor,
            self.factory.local_host,
            self.factory.local_port)
        SOCKSPoint = SOCKS4ClientEndpoint(
            self.factory.remote_host,
            self.factory.remote_port,
            TCPPoint)
        d = SOCKSPoint.connect(client)
        @d.addErrback
        def _gotError(error):
            log.err(error, "error connecting to SOCKS server")

class SOCKS4WrapperFactory(Factory):
    protocol = SOCKS4Wrapper

    def __init__(self, local_host, local_port, remote_host, remote_port):
        self.local_host = local_host
        self.local_port = local_port
        self.remote_host = remote_host
        self.remote_port = remote_port

def main(*args):
    # config
    ob_client = os.getenv("OBFSPROXY", "obfsproxy")
    fp_client = os.getenv("FLASHPROXY_CLIENT", "flashproxy-client")
    fp_local_port = int(os.getenv("FLASHPROXY_LOCAL_PORT", 9001))
    fp_remote_port = int(os.getenv("FLASHPROXY_REMOTE_PORT", 9000))
    mid_port = 2334

    # runtime state
    client = ClientTransportPlugin.fromEnv()
    client.init(['obfs3_flash'])
    cur_env = pt_child_env(os.environ, client.config.getManagedTransportVersions())

    from twisted.internet import reactor
    auto_killall(1, cleanup=lambda:reactor.stop())

    fp_proc = Popen(
        [fp_client, ":%s" % fp_local_port, ":%s" % fp_remote_port],
        stdout = SINK,
        env = dict(cur_env + {
            "TOR_PT_CLIENT_TRANSPORTS": "websocket",
        }.items()),
        )

    reactor.listenTCP(interface='127.0.0.1', port=mid_port, factory=
        SOCKS4WrapperFactory('127.0.0.1', fp_local_port, '0.0.1.0', 1))

    ob_proc = Popen(
        [ob_client, "managed"],
        stdout = PIPE,
        env = dict(cur_env + {
            "TOR_PT_CLIENT_TRANSPORTS": "obfs3",
        }.items()),
        )

    stdio.StandardIO(PTInterceptor(client),
        stdin=ob_proc.stdout.fileno(), reactor=reactor)

    reactor.run(installSignalHandlers=0)
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
