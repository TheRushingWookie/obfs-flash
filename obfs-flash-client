#!/usr/bin/python

import argparse
import os
import sys

from collections import namedtuple
from functools import partial

# TODO(infinity0): this is temporary workaround until we do #10047
if sys.platform == 'win32':
    os.environ["KILL_CHILDREN_ON_DEATH"] = "1"
from pyptlib.util import parse_addr_spec
from pyptlib.util.subproc import auto_killall, Popen
from pyptlib.client import ClientTransportPlugin

from subprocess import PIPE

from twisted.internet.defer import Deferred, DeferredList
from twisted.internet.stdio import StandardIO
from twisted.internet.protocol import Factory, connectionDone
from twisted.internet.endpoints import TCP4ClientEndpoint
from twisted.protocols.basic import LineReceiver
from twisted.protocols.portforward import ProxyServer as _ProxyServer
from twisted.python import log
from txsocksx.client import SOCKS4ClientEndpoint

import shlex

import logging


def pt_child_env(managed_ver, env=os.environ):
    """
    Prepare the environment for a child PT process, by clearing all TOR_PT_*
    envvars except TOR_PT_STATE_LOCATION and TOR_PT_MANAGED_TRANSPORT_VER.
    """
    exempt = ['TOR_PT_STATE_LOCATION']
    cur_env = [(k, v) for k, v in env.iteritems()
                      if not k.startswith('TOR_PT_') or k in exempt]
    cur_env.append(('TOR_PT_MANAGED_TRANSPORT_VER', ','.join(managed_ver)))
    return cur_env

class MethodSpec(namedtuple('MethodSpec', 'name protocol addrport args opts')):
    @classmethod
    def fromLine(cls, line):
        args = line.rstrip('\n').split(' ')
        name = args[0]
        protocol = args[1]
        addrport = parse_addr_spec(args[2])
        args = args[3][-5:].split(',') if len(args) > 3 and args[3].startswith("ARGS=") else []
        opts = args[4][-9:].split(',') if len(args) > 4 and args[4].startswith("OPT-ARGS=") else []
        return MethodSpec(name, protocol, addrport, args, opts)

def branch(parent):
    """
    Returns a new Deferred that does not advance the callback-chain of the parent.

    See http://xph.us/2009/12/10/asynchronous-programming-in-python.html for motivation.
    """
    d = Deferred()
    parent.addCallback(lambda v: (v, d.callback(v))[0])
    parent.addErrback(lambda f: (f, d.errback(f))[1])
    return d

class ManagedTransportProtocolV1(LineReceiver):
    """
    A Twisted IProtocol to read PT output.

    See pt-spec.txt and others for details of the protocol.
    """
    # TODO(infinity0): eventually this could be padded out and moved to pyptlib

    delimiter = os.linesep
    protocol_version = "1"

    def __init__(self):
        self.cmethods = {}
        self._dCMethodsDone = Deferred()
        self._dPluginError = Deferred()
        # dPluginError triggers errors on all sub-events, not the other way round
        # so fatal sub-events should call _abort rather than errback on their Deferreds
        self._dPluginError.addErrback(lambda f: (f, self._fireCMethodsDone().errback(f))[0])
        # TODO(infinity0): call _abort if we don't recv CMETHODS DONE within n sec

    def whenCMethodsDone(self):
        """
        Return a new Deferred that calls-back when CMETHODS DONE is received.
        """
        return branch(self._dCMethodsDone)

    def whenPluginError(self):
        """
        Return a new Deferred that errors-back when the remote plugin fails.

        Note: the success chain (callback) is never fired.
        """
        return branch(self._dPluginError)

    def lineReceived(self, line):
        if not line: return

        (kw, args) = line.split(' ', 1)
        if kw == "VERSION":
            version = args.strip()
            if version != self.protocol_version:
                self._abort(ValueError("child used unsupported managed transport version: %s" % version))
        elif kw == "CMETHOD":
            cmethod = MethodSpec.fromLine(args)
            self.cmethods[cmethod.name] = cmethod
        elif kw == "CMETHODS" and args == "DONE":
            self._fireCMethodsDone().callback(self.cmethods)
        else:
            pass # ignore unrecognised line

    def connectionLost(self, reason=connectionDone):
        self._firePluginError().errback(reason)

    def _abort(self, exc):
        self._firePluginError().errback(exc)
        self.transport.loseConnection()

    def _fireCMethodsDone(self):
        """Return dCMethodsDone or a dummy if it was already called."""
        if self._dCMethodsDone:
            d = self._dCMethodsDone
            self._dCMethodsDone = None
            return d
        return Deferred().addErrback(lambda *args: None)

    def _firePluginError(self):
        """Return dPluginError or a dummy if it was already called."""
        if self._dPluginError:
            d = self._dPluginError
            self._dPluginError = None
            return d
        return Deferred().addErrback(lambda *args: None)

# TODO(infinity0): remove this class when twisted update their side
class ProxyServer(_ProxyServer):

    def connectionMade(self):
        # code copied from super class, except instead of connecting
        # to a TCP endpoint we abstract that out to a child method
        self.transport.pauseProducing()

        client = self.clientProtocolFactory()
        client.setServer(self)

        if self.reactor is None:
            from twisted.internet import reactor
            self.reactor = reactor

        self.connectProxyClient(client)

    def connectProxyClient(self, client):
        raise NotImplementedError()

class SOCKS4Wrapper(ProxyServer):

    def connectProxyClient(self, client):
        TCPPoint = TCP4ClientEndpoint(
            self.reactor,
            self.factory.local_host,
            self.factory.local_port)
        SOCKSPoint = SOCKS4ClientEndpoint(
            self.factory.remote_host,
            self.factory.remote_port,
            TCPPoint)
        d = SOCKSPoint.connect(client)
        @d.addErrback
        def _gotError(error):
            log.err(error, "error connecting to SOCKS server")

class SOCKS4WrapperFactory(Factory):
    protocol = SOCKS4Wrapper

    def __init__(self, local_host, local_port, remote_host, remote_port):
        self.local_host = local_host
        self.local_port = local_port
        self.remote_host = remote_host
        self.remote_port = remote_port

if sys.platform == "win32":
    # TODO(infinity0): push this upstream to Twisted
    from twisted.internet import _pollingfile
    import msvcrt

    _StandardIO = StandardIO
    class StandardIO(_StandardIO):

        def __init__(self, proto, stdin=None, stdout=None, reactor=None):
            """
            Start talking to standard IO with the given protocol.

            Also, put it stdin/stdout/stderr into binary mode.
            """
            if reactor is None:
                import twisted.internet.reactor
                reactor = twisted.internet.reactor

            _pollingfile._PollingTimer.__init__(self, reactor)
            self.proto = proto

            fdstdin = stdin or sys.stdin.fileno()
            fdstdout = stdout or sys.stdout.fileno()

            for stdfd in (fdstdin, fdstdout):
                msvcrt.setmode(stdfd, os.O_BINARY)

            hstdin = msvcrt.get_osfhandle(fdstdin)
            self.stdin = _pollingfile._PollableReadPipe(
                hstdin, self.dataReceived, self.readConnectionLost)

            hstdout = msvcrt.get_osfhandle(fdstdout)
            self.stdout = _pollingfile._PollableWritePipe(
                hstdout, self.writeConnectionLost)

            self._addPollableResource(self.stdin)
            self._addPollableResource(self.stdout)

            self.proto.makeConnection(self)

def pt_launch_child(reactor, client, methodnames, pt_method_name, cmdline):
    """Launch a child PT and ensure it has the right transport methods."""
    cur_env = pt_child_env(ManagedTransportProtocolV1.protocol_version)
    environment = dict(cur_env + {
            "TOR_PT_CLIENT_TRANSPORTS": ",".join(methodnames),
        }.items())
    sub_proc = Popen(cmdline,
        stdout = PIPE,
        env = environment,
        )
    sub_protocol = ManagedTransportProtocolV1()
    # we ought to pass reactor=reactor in below, but this breaks Twisted 12
    StandardIO(sub_protocol, stdin=sub_proc.stdout.fileno())
    methoddefers = [sub_protocol.whenCMethodsDone().addCallback(
                        partial(pt_require_child, client, name, pt_method_name))
                    for name in methodnames]
    return sub_proc, sub_protocol, methoddefers

def pt_require_child(client, childmethod, pt_method_name, cmethods):
    """Callback for checking a child PT has the right transport methods."""
    if childmethod not in cmethods:
        client.reportMethodError(pt_method_name, "failed to start required child transport: %s" % childmethod)
        raise ValueError()
    return cmethods[childmethod]

def pt_setup_socks_proxy(pt_name, pt_chain, success_list, dest_address, dest_port, reactor, listen_port=0):
    """Launches a socks proxy server to link two PTs together.
    :param str pt_name: The name of the pt to send traffic to.
    :param list pt_chain: The list of PTs in this chain.
    :param list success_list: A list of tuples containing a launch status boolean, MethodSpec pairs.
        Ex: [(True, MethodSpec(name='dummy', protocol='socks4', addrport=('127.0.0.1', 58982), args=[], opts=[])),
            (True, MethodSpec(name='b64', protocol='socks4', addrport=('127.0.0.1', 58981), args=[], opts=[]))]
    :param str dest_address: The address for the next PT to send its results to.
    :param int dest_port: The port for the next PT to send to.
    :param twisted.internet.interfaces.IReactor reactor: Reactor to attack the TCP server to.
    :param int listen_port. The port to for the TCP server to listen on. Default is chosen by the OS."""

    methodspec = [r[1] for r in success_list if r[1].name == pt_name][0] # Returns the resulting methodspec.
    proxy_server = reactor.listenTCP(interface='127.0.0.1', port=listen_port, factory=
                                    SOCKS4WrapperFactory(methodspec.addrport[0], methodspec.addrport[1], dest_address, dest_port))
    return proxy_server.getHost().port

def pt_launch_chain(reactor, client, callback_port, configuration, pt_method_name):
    """
    Launches a chain of pluggable transports.
    :param twisted.internet.interfaces.IReactor reactor: Reactor to install this PT to.
    :param pyptlib.client.ClientTransportPlugin client: PT client API.
    :param int callback_port: Local listen port for the first PT to connect to.
    :param Config configuration: The configuration structure for this pair.
    :param str pt_method_name: The name of the pt chain to launch. Ex: "obfs3_flashproxy"
    """

    # Temporary hardcoded ip/port
    dest_address = '127.0.0.1'
    dest_port = 2400

    if pt_method_name in configuration.alias_map:
        pt_chain = configuration.alias_map[pt_method_name]
    else:
        logging.error('Pluggable Transport Combination %s not found in configuration alias map.' % pt_method_name)
        raise KeyError()

    defer_list = []

    if len(pt_chain) < 2:
        raise ValueError("PT Chain %s does not contain enough transports." % pt_chain)

    for pt in pt_chain:
        if pt in configuration.transport_map:
            pt_cmdline = configuration.transport_map[pt]
        else:
            raise ValueError("Pluggable transport %s not found in transport_map. Check your configuration file." % pt)
        _, _, defer = pt_launch_child(reactor, client, [pt], pt_method_name, pt_cmdline)
        defer_list.extend(defer)
    whenAllDone = DeferredList(defer_list, consumeErrors=False)

    def allDone(success_list):
        """
        Connects the pluggable transports together through SOCKS proxies.
        :param list success_list: A list of tuples containing a launch status boolean, MethodSpec pairs.
        Ex: [(True, MethodSpec(name='dummy', protocol='socks4', addrport=('127.0.0.1', 58982), args=[], opts=[])),
         (True, MethodSpec(name='b64', protocol='socks4', addrport=('127.0.0.1', 58981), args=[], opts=[]))]
        """

        success = all(r[0] for r in success_list if r[1].name in pt_chain)
        # failure was already reported by pt_require_child, just return
        if not success: return

        #This TCP server forwards the data to the last pt, which then sends the data to the actual bridge address
        last_pt_name = pt_chain[-1]
        # Initialize prev_port to the first port picked by the last proxy as that's the only one we know yet.
        listen_port = 0 if len(pt_chain) > 2 else callback_port
        prev_port = pt_setup_socks_proxy(last_pt_name, pt_chain, success_list, dest_address, dest_port, reactor, listen_port)

        if len(pt_chain) > 2:
            for pt_name in reversed(pt_chain[2:-1]):
                #Loops through the middle pts linking them together through SOCKS proxies, skipping the first and last pts.
                prev_port = pt_setup_socks_proxy(pt_name, pt_chain, success_list, '127.0.0.1', prev_port, reactor)

            # Links the second server to listen on the given callback_port
            pt_name = pt_chain[1]
            prev_port = pt_setup_socks_proxy(pt_name, pt_chain, success_list, '127.0.0.1', prev_port, reactor, listen_port=callback_port)

        # now report success of the overall composed PT
        first_pt_name = pt_chain[0]
        first_methodspec = [r[1] for r in success_list if r[1].name == first_pt_name and r[1].name in pt_chain][0]
        client.reportMethodSuccess(pt_method_name, first_methodspec.protocol, first_methodspec.addrport)
        client.reportMethodsEnd()
    whenAllDone.addCallback(allDone)

class Config():
    # Transport map links a pluggable transport name to the a commandline to launch it.
    # Ex: {'b64' : 'exec obfsproxy managed'}
    transport_map = None

    #Alias map links a pluggable transport chain name to a list of individual pluggable transports
    # Ex: {'dummy_b64_dummy2' : ['dummy''b64''dummy2']}
    alias_map = None

    def __init__(self, transport_map, alias_map):
        self.transport_map = transport_map
        self.alias_map = alias_map

    def __repr__(self):
        return "Config(%s, %s)" % (self.transport_map, self.alias_map)

    def __str__(self):
        return "Config Object with transport_map: %s, and alias_map %s." % (self.transport_map, self.alias_map)

    @classmethod
    def parse(cls, config_string):
        """
        Reads a configuration string and returns an instance of configuration. Uses shlex to parse configuration lines.
        :param str config_string: The string which will be parsed to populate the transport_map and alias_map hash tables.
        See the file example-fog-config for format.
        """
        # TODO Add possibility of reading a ClientTransportPlugin with multiple transport types
        # Ex: ClientTransportPlugin obfs3,scramblesuit obfsclient --option=value

        line_counter = 0
        lines = config_string.split('\n')
        transport_map = {}
        alias_map = {}

        for line in lines:
            line_counter += 1
            if len(line) > 0 and line[0] != '#' : # Check for empty lines and comment tags on the first
                line = line.strip()
                delimited_tokens = shlex.split(line)
                if len(delimited_tokens) > 1:
                    config_line_type = delimited_tokens[0] # This can be either Alias or ClientTransportPlugin
                    if config_line_type == 'ClientTransportPlugin':
                        cls.parse_transport_line(transport_map, delimited_tokens, line_counter)
                    elif config_line_type == 'Alias':
                        cls.parse_alias_line(alias_map, transport_map, delimited_tokens, line_counter)
                    else:
                        logging.warn("Configuration file has unknown line %s: '%s'" % (line_counter, line))
        return cls(transport_map, alias_map)

    @classmethod
    def parse_transport_line(cls, transport_map, delimited_tokens, line_counter):
        transport_name = delimited_tokens[1]
        transport_cmdline = delimited_tokens[2:]
        if transport_name in transport_map:
            raise ValueError('Configuration file has duplicate ClientTransportPlugin lines. Duplicate line is at line number %s' % line_counter)
        transport_map[transport_name] = transport_cmdline

    @classmethod
    def parse_alias_line(cls, alias_map, transport_map, delimited_tokens, line_counter):
        alias_name = delimited_tokens[1] # Example: "obfs3_flashproxy"
        alias_path = delimited_tokens[2].split('|') # Example: "obfs3|flashproxy"
        if alias_name in alias_map:
            raise ValueError('Configuration file has duplicate Alias lines. Duplicate line is at line number %s' % line_counter)
        for pt_name in alias_path:
            if pt_name not in transport_map:
                raise KeyError('Transport map is missing pluggable transport %s needed for chain %s. Check your configuration file for a ClientTransportPlugin line can launch %s' % (pt_name, alias_name, pt_name))
        alias_map[alias_name] = alias_path

def obfs3_flashproxy(reactor, client, callback_port, fp_remote, fp_args=[], fp_local=0):
    """
    Set up the obfs3_flashproxy combined PT.

    :param twisted.internet.interfaces.IReactor reactor: Reactor to install this PT to.
    :param pyptlib.client.ClientTransportPlugin client: PT client API.
    :param int callback_port: Local listen port for obfsproxy to connect to.
    :param str fp_remote: Listen address for remote flashproxy connections.
    :param int fp_local: Local listen port for local flashproxy connections.
    """

    ob_client = os.getenv("OBFSPROXY", "obfsproxy")
    fp_client = os.getenv("FLASHPROXY_CLIENT", "flashproxy-client")

    fp_cmdline =  [fp_client, "--transport", 'obfs3|websocket'] + fp_args + ['127.0.0.1:%s' % fp_local, fp_remote]
    obfs_cmd_line = [ob_client, "managed"]

    transport_map = {'obfs3': obfs_cmd_line, 'flashproxy': fp_cmdline}
    alias_map = {'obfs3_flashproxy': ['obfs3', 'flashproxy']}

    configuration = Config(transport_map, alias_map)
    pt_launch_chain(reactor, client, callback_port, configuration, "obfs3_flashproxy") # Launch

def main(*args):
    parser = argparse.ArgumentParser()
    parser.add_argument("callback_port", help="local listen port for obfsproxy to "
        "connect to. This must match the appropriate bridge line in your " # TODO print bridge line
        "torrc.",
        metavar='PORT', type=int)
    parser.add_argument("fp_remote", help="remote connections listen address "
        "for flashproxy, default %(default)s",
        metavar='REMOTE:PORT', nargs='?', default=":9000")
    parser.add_argument("--fp-arg", help="arguments for flashproxy-client",
        metavar='ARG', action='append')
    parser.add_argument("-f", help="fog configuration file path",
        metavar='FOGFILE', type=argparse.FileType('r'))

    # TODO(infinity0): add an "external" mode, which would require us to run
    # obfsproxy in external mode too.

    opts = parser.parse_args(args)

    # ensure string address is valid
    _, _, = parse_addr_spec(opts.fp_remote, defhost="0.0.0.0")
    configuration = None

    if opts.f:
        file_contents = opts.f.read()
        configuration = Config.parse(file_contents)
        pt_method_names = configuration.alias_map.keys()
    else:
        pt_method_names = ["obfs3_flashproxy"]

    client = ClientTransportPlugin()
    client.init(pt_method_names) # Initialize our possible methods to all the chains listed by the fog file and stored in alias map.
    if not client.getTransports():
        logging.error("no transports to serve. pt_method_names may be invalid.")
        return 1

    from twisted.internet import reactor
    auto_killall(1, cleanup=reactor.stop)
    #TODO Change from launching a single pair to launching multiple chains.
    if configuration:
        pt_launch_chain(reactor, client, opts.callback_port, configuration, pt_method_names[0])
    else:
        logging.warn("No configuration file specified. Defaulting to launching obfs3|flashproxy pair.")
        obfs3_flashproxy(reactor, client, opts.callback_port, opts.fp_remote, opts.fp_arg or [])

    reactor.run(installSignalHandlers=0)
    return 0

if __name__ == "__main__":
    sys.exit(main(*sys.argv[1:]))

