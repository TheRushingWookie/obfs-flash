#!/usr/bin/python

import argparse
import os
import sys

from collections import namedtuple
from functools import partial

# TODO(infinity0): this is temporary workaround until we do #10047
if sys.platform == 'win32':
    os.environ["KILL_CHILDREN_ON_DEATH"] = "1"
from pyptlib.util import parse_addr_spec
from pyptlib.util.subproc import auto_killall, Popen
from pyptlib.client import ClientTransportPlugin

from subprocess import PIPE

from twisted.internet.defer import Deferred, DeferredList
from twisted.internet.stdio import StandardIO
from twisted.internet.protocol import Factory, connectionDone
from twisted.internet.endpoints import TCP4ClientEndpoint
from twisted.protocols.basic import LineReceiver
from twisted.protocols.portforward import ProxyServer as _ProxyServer
from twisted.python import log
from txsocksx.client import SOCKS4ClientEndpoint

import shlex

import logging

PT_METHOD_NAME = "obfs3_flashproxy"

def pt_child_env(managed_ver, env=os.environ):
    """
    Prepare the environment for a child PT process, by clearing all TOR_PT_*
    envvars except TOR_PT_STATE_LOCATION and TOR_PT_MANAGED_TRANSPORT_VER.
    """
    exempt = ['TOR_PT_STATE_LOCATION']
    cur_env = [(k, v) for k, v in env.iteritems()
                      if not k.startswith('TOR_PT_') or k in exempt]
    cur_env.append(('TOR_PT_MANAGED_TRANSPORT_VER', ','.join(managed_ver)))
    return cur_env

class CMethod(namedtuple('MethodSpec', 'name protocol addrport args opts')):
    @classmethod
    def fromLine(cls, line):
        args = line.rstrip('\n').split(' ')
        name = args[0]
        protocol = args[1]
        addrport = parse_addr_spec(args[2])
        args = args[3][-5:].split(',') if len(args) > 3 and args[3].startswith("ARGS=") else []
        opts = args[4][-9:].split(',') if len(args) > 4 and args[4].startswith("OPT-ARGS=") else []
        return CMethod(name, protocol, addrport, args, opts)

def branch(parent):
    """
    Returns a new Deferred that does not advance the callback-chain of the parent.

    See http://xph.us/2009/12/10/asynchronous-programming-in-python.html for motivation.
    """
    d = Deferred()
    parent.addCallback(lambda v: (v, d.callback(v))[0])
    parent.addErrback(lambda f: (f, d.errback(f))[1])
    return d

class ManagedTransportProtocolV1(LineReceiver):
    """
    A Twisted IProtocol to read PT output.

    See pt-spec.txt and others for details of the protocol.
    """
    # TODO(infinity0): eventually this could be padded out and moved to pyptlib

    delimiter = os.linesep
    protocol_version = "1"

    def __init__(self):
        self.cmethods = {}
        self._dCMethodsDone = Deferred()
        self._dPluginError = Deferred()
        # dPluginError triggers errors on all sub-events, not the other way round
        # so fatal sub-events should call _abort rather than errback on their Deferreds
        self._dPluginError.addErrback(lambda f: (f, self._fireCMethodsDone().errback(f))[0])
        # TODO(infinity0): call _abort if we don't recv CMETHODS DONE within n sec

    def whenCMethodsDone(self):
        """
        Return a new Deferred that calls-back when CMETHODS DONE is received.
        """
        return branch(self._dCMethodsDone)

    def whenPluginError(self):
        """
        Return a new Deferred that errors-back when the remote plugin fails.

        Note: the success chain (callback) is never fired.
        """
        return branch(self._dPluginError)

    def lineReceived(self, line):
        if not line: return

        (kw, args) = line.split(' ', 1)
        if kw == "VERSION":
            version = args.strip()
            if version != self.protocol_version:
                self._abort(ValueError("child used unsupported managed transport version: %s" % version))
        elif kw == "CMETHOD":
            cmethod = CMethod.fromLine(args)
            self.cmethods[cmethod.name] = cmethod
        elif kw == "CMETHODS" and args == "DONE":
            self._fireCMethodsDone().callback(self.cmethods)
        else:
            pass # ignore unrecognised line

    def connectionLost(self, reason=connectionDone):
        self._firePluginError().errback(reason)

    def _abort(self, exc):
        self._firePluginError().errback(exc)
        self.transport.loseConnection()

    def _fireCMethodsDone(self):
        """Return dCMethodsDone or a dummy if it was already called."""
        if self._dCMethodsDone:
            d = self._dCMethodsDone
            self._dCMethodsDone = None
            return d
        return Deferred().addErrback(lambda *args: None)

    def _firePluginError(self):
        """Return dPluginError or a dummy if it was already called."""
        if self._dPluginError:
            d = self._dPluginError
            self._dPluginError = None
            return d
        return Deferred().addErrback(lambda *args: None)

# TODO(infinity0): remove this class when twisted update their side
class ProxyServer(_ProxyServer):

    def connectionMade(self):
        # code copied from super class, except instead of connecting
        # to a TCP endpoint we abstract that out to a child method
        self.transport.pauseProducing()

        client = self.clientProtocolFactory()
        client.setServer(self)

        if self.reactor is None:
            from twisted.internet import reactor
            self.reactor = reactor

        self.connectProxyClient(client)

    def connectProxyClient(self, client):
        raise NotImplementedError()

class SOCKS4Wrapper(ProxyServer):

    def connectProxyClient(self, client):
        TCPPoint = TCP4ClientEndpoint(
            self.reactor,
            self.factory.local_host,
            self.factory.local_port)
        SOCKSPoint = SOCKS4ClientEndpoint(
            self.factory.remote_host,
            self.factory.remote_port,
            TCPPoint)
        d = SOCKSPoint.connect(client)
        @d.addErrback
        def _gotError(error):
            log.err(error, "error connecting to SOCKS server")

class SOCKS4WrapperFactory(Factory):
    protocol = SOCKS4Wrapper

    def __init__(self, local_host, local_port, remote_host, remote_port):
        self.local_host = local_host
        self.local_port = local_port
        self.remote_host = remote_host
        self.remote_port = remote_port

if sys.platform == "win32":
    # TODO(infinity0): push this upstream to Twisted
    from twisted.internet import _pollingfile
    import msvcrt

    _StandardIO = StandardIO
    class StandardIO(_StandardIO):

        def __init__(self, proto, stdin=None, stdout=None, reactor=None):
            """
            Start talking to standard IO with the given protocol.

            Also, put it stdin/stdout/stderr into binary mode.
            """
            if reactor is None:
                import twisted.internet.reactor
                reactor = twisted.internet.reactor

            _pollingfile._PollingTimer.__init__(self, reactor)
            self.proto = proto

            fdstdin = stdin or sys.stdin.fileno()
            fdstdout = stdout or sys.stdout.fileno()

            for stdfd in (fdstdin, fdstdout):
                msvcrt.setmode(stdfd, os.O_BINARY)

            hstdin = msvcrt.get_osfhandle(fdstdin)
            self.stdin = _pollingfile._PollableReadPipe(
                hstdin, self.dataReceived, self.readConnectionLost)

            hstdout = msvcrt.get_osfhandle(fdstdout)
            self.stdout = _pollingfile._PollableWritePipe(
                hstdout, self.writeConnectionLost)

            self._addPollableResource(self.stdin)
            self._addPollableResource(self.stdout)

            self.proto.makeConnection(self)

def pt_launch_child(reactor, client, methodnames, cmdline):
    """Launch a child PT and ensure it has the right transport methods."""
    cur_env = pt_child_env(ManagedTransportProtocolV1.protocol_version)
    environment = dict(cur_env + {
            "TOR_PT_CLIENT_TRANSPORTS": ",".join(methodnames),
        }.items())
    sub_proc = Popen(cmdline,
        stdout = PIPE,
        env = environment,
        )
    sub_protocol = ManagedTransportProtocolV1()
    # we ought to pass reactor=reactor in below, but this breaks Twisted 12
    StandardIO(sub_protocol, stdin=sub_proc.stdout.fileno())
    methoddefers = [sub_protocol.whenCMethodsDone().addCallback(
                        partial(pt_require_child, client, name))
                    for name in methodnames]
    return sub_proc, sub_protocol, methoddefers

def pt_require_child(client, childmethod, cmethods):
    """Callback for checking a child PT has the right transport methods."""
    if childmethod not in cmethods:
        client.reportMethodError(PT_METHOD_NAME, "failed to start required child transport: %s" % childmethod)
        raise ValueError()
    return cmethods[childmethod]



def launch_pt_pair(reactor, client, callback_port, configuration):
    """
    Launches a pair of pluggable transports. Currently only supports chaining two transports together.
    The pair is set by PT_METHOD_NAME
    :param twisted.internet.interfaces.IReactor reactor: Reactor to install this PT to.
    :param pyptlib.client.ClientTransportPlugin client: PT client API.
    :param int callback_port: Local listen port for obfsproxy to connect to.
    """
    if PT_METHOD_NAME in configuration.alias_map:
        pt_chain = configuration.alias_map[PT_METHOD_NAME]
    else:
        logging.error('Pluggable Transport Combination %s not found in configuration alias map.' % PT_METHOD_NAME)
        raise KeyError()

    defer_list = []

    for pt in pt_chain:
        if pt in configuration.transport_map:
            pt_cmdline = configuration.transport_map[pt]
        else:
            logging.error("Pluggable transport %s not found in transport_map. Check your configuration file." % str(pt))
            raise ValueError()
        _, _, defer = pt_launch_child(reactor, client, [pt], pt_cmdline)
        defer_list.append(defer[0])
    whenAllDone = DeferredList(defer_list, consumeErrors=False)

    def allDone(success_list):

        success = all(r[0] for r in success_list)
        # failure was already reported by pt_require_child, just return
        if not success: return

        result1 = [r[1] for r in success_list if r[1].name == pt_chain[0]][0] # Normally obfs3 result
        result2 = [r[1] for r in success_list if r[1].name == pt_chain[1]][0] # Normally flashproxy result
        destination_port = result2.addrport[1] # if port was 0, read the actual port
        # shim to wrap obfs data output to SOCKS input for flashproxy
        reactor.listenTCP(interface='127.0.0.1', port=callback_port, factory=
            SOCKS4WrapperFactory('127.0.0.1', destination_port, '0.0.1.0', 1))
        # now report success of the overall composed PT
        client.reportMethodSuccess(PT_METHOD_NAME, result1.protocol, result1.addrport)
        client.reportMethodsEnd()
    whenAllDone.addCallback(allDone)


class Config():

    transport_map = {}
    alias_map = {}
    def __init__(self, transport_map, alias_map):
        self.transport_map = transport_map
        self.alias_map = alias_map

    def __repr__(self):
        return "Config(" + str(self.transport_map) + ", " + str(self.alias_map) + ")"

    @classmethod
    def parse(cls, config_string):
        """
        Reads a configuration string and returns an instance of configuration. Uses shlex to parse configuration lines.
        :param String config_string: The string which will be parsed to populate the transport_map and alias_map hash tables.
        See the file example-fog-config for format.
        """
        # TODO Add possibility of reading a ClientTransportPlugin with multiple transport types
        # EX: ClientTransportPlugin obfs3,scramblesuit obfsclient --option=value
        transport_map = {}
        alias_map = {}
        line_counter = 0
        lines = config_string.split('\n')

        for line in lines:
            line_counter += 1
            if len(line) > 0: # Check for empty lines
                line = line.strip()
                lexer = shlex.shlex(line)
                lexer.whitespace_split = True # Ensure shlex only splits on whitespace instead of splitting on pipes and dashes too.
                delimited_tokens = list(lexer)
                if len(delimited_tokens) > 1:
                    config_line_type = delimited_tokens[0] # This can be either Alias or ClientTransportPlugin
                    if config_line_type == 'ClientTransportPlugin':
                        transport_name = delimited_tokens[1]
                        transport_cmdline = delimited_tokens[2:]
                        if transport_name in transport_map:
                            logging.warn('Configuration file has duplicate ClientTransportPlugin lines. Duplicate line is at line number %s' % str(line_counter))
                        transport_map[transport_name] = transport_cmdline
                    elif config_line_type == 'Alias':
                        alias_name = delimited_tokens[1] # Example: "obfs_flashproxy"
                        alias_path = delimited_tokens[2].split('|') # Example: "obfs3|flashproxy"
                        if alias_name in alias_map:
                            logging.warn('Configuration file has duplicate Alias lines. Duplicate line is at line number %s' % str(line_counter))
                        alias_map[alias_name] = alias_path
                    else:
                        logging.warning("Configuration file has unknown line %s: '%s'" % (str(line_counter), line))
        return cls(transport_map, alias_map)

def obfs3_flashproxy(reactor, client, callback_port, fp_remote, fp_args=[], fp_local=0):
    """
    Set up the obfs3_flashproxy combined PT.

    :param twisted.internet.interfaces.IReactor reactor: Reactor to install this PT to.
    :param pyptlib.client.ClientTransportPlugin client: PT client API.
    :param int callback_port: Local listen port for obfsproxy to connect to.
    :param str fp_remote: Listen address for remote flashproxy connections.
    :param int fp_local: Local listen port for local flashproxy connections.
    """

    ob_client = os.getenv("OBFSPROXY", "obfsproxy")
    fp_client = os.getenv("FLASHPROXY_CLIENT", "flashproxy-client")

    fp_cmdline =  [fp_client, "--transport", '"obfs3|websocket"'] + fp_args + ['127.0.0.1:%s' % fp_local, fp_remote]
    obfs_cmd_line = [ob_client, "managed"]

    transport_map = {'obfs3': obfs_cmd_line, 'flashproxy': fp_cmdline}
    alias_map = {'obfs3_flashproxy': ['obfs3', 'flashproxy']}

    configuration = Config(transport_map, alias_map)
    launch_pt_pair(reactor, client, callback_port, configuration) # Launch

def main(*args):
    parser = argparse.ArgumentParser()
    parser.add_argument("callback_port", help="local listen port for obfsproxy to "
        "connect to. This must match the appropriate bridge line in your " # TODO print bridge line
        "torrc.",
        metavar='PORT', type=int)
    parser.add_argument("fp_remote", help="remote connections listen address "
        "for flashproxy, default %(default)s",
        metavar='REMOTE:PORT', nargs='?', default=":9000")
    parser.add_argument("--fp-arg", help="arguments for flashproxy-client",
        metavar='ARG', action='append')
    parser.add_argument("-fogfile", help="fog configuration file path",
        metavar='FOG FILE', type=argparse.FileType('r'))
    parser.add_argument("-pt_method_name", help="The plugin chain to be run.",
        metavar='PT METHOD NAME')

    # TODO(infinity0): add an "external" mode, which would require us to run
    # obfsproxy in external mode too.

    opts = parser.parse_args(args)

    # ensure str address is valid
    _, _, = parse_addr_spec(opts.fp_remote, defhost="0.0.0.0")
    configuration = None

    if opts.pt_method_name:
        PT_METHOD_NAME = opts.pt_method_name
    else:
        PT_METHOD_NAME = "obfs3_flashproxy"

    if opts.fogfile:
        file_contents = opts.fogfile.read()
        configuration = Config.parse(file_contents)

    client = ClientTransportPlugin()
    client.init([PT_METHOD_NAME])
    if not client.getTransports():
        logging.error("no transports to serve. pt_method_name may be invalid.")
        return 1

    from twisted.internet import reactor
    auto_killall(1, cleanup=reactor.stop)
    if configuration:
        launch_pt_pair(reactor, client, opts.callback_port, configuration)
    else:
        logging.warning("No configuration file specified. Defaulting to launching obfs|flashproxy pair.")
        obfs3_flashproxy(reactor, client, opts.callback_port, opts.fp_remote, opts.fp_arg or [])

    reactor.run(installSignalHandlers=0)
    return 0

if __name__ == "__main__":
    sys.exit(main(*sys.argv[1:]))

