#!/usr/bin/python

import argparse
import os
import sys

from collections import namedtuple
from functools import partial

# TODO(infinity0): this is temporary workaround until we do #10047
if sys.platform == 'win32':
    os.environ["KILL_CHILDREN_ON_DEATH"] = "1"
from pyptlib.util import parse_addr_spec
from pyptlib.util.subproc import auto_killall, Popen
from pyptlib.client import ClientTransportPlugin

from subprocess import PIPE

from twisted.internet.defer import Deferred, DeferredList
from twisted.internet.stdio import StandardIO
from twisted.internet.protocol import Factory, connectionDone
from twisted.internet.endpoints import TCP4ClientEndpoint
from twisted.protocols.basic import LineReceiver
from twisted.protocols.portforward import ProxyServer as _ProxyServer
from twisted.python import log
from txsocksx.client import SOCKS4ClientEndpoint
from fog.socks import SOCKSv4InterceptorFactory

import shlex

import logging

logger = None
def pt_setup_logger():
    global logger
    logger = logging.getLogger('obfs-flash-logger')
    logger.setLevel(logging.WARNING)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    logger.addHandler(ch)

def pt_child_env(managed_ver, env=os.environ):
    """
    Prepare the environment for a child PT process, by clearing all TOR_PT_*
    envvars except TOR_PT_STATE_LOCATION and TOR_PT_MANAGED_TRANSPORT_VER.
    """
    exempt = ['TOR_PT_STATE_LOCATION']
    cur_env = [(k, v) for k, v in env.iteritems()
                      if not k.startswith('TOR_PT_') or k in exempt]
    cur_env.append(('TOR_PT_MANAGED_TRANSPORT_VER', ','.join(managed_ver)))
    return cur_env

class MethodSpec(namedtuple('MethodSpec', 'name protocol addrport args opts')):
    @classmethod
    def fromLine(cls, line):
        args = line.rstrip('\n').split(' ')
        name = args[0]
        protocol = args[1]
        addrport = parse_addr_spec(args[2])
        args = args[3][-5:].split(',') if len(args) > 3 and args[3].startswith("ARGS=") else []
        opts = args[4][-9:].split(',') if len(args) > 4 and args[4].startswith("OPT-ARGS=") else []
        return MethodSpec(name, protocol, addrport, args, opts)

def branch(parent):
    """
    Returns a new Deferred that does not advance the callback-chain of the parent.

    See http://xph.us/2009/12/10/asynchronous-programming-in-python.html for motivation.
    """
    d = Deferred()
    parent.addCallback(lambda v: (v, d.callback(v))[0])
    parent.addErrback(lambda f: (f, d.errback(f))[1])
    return d

class ManagedTransportProtocolV1(LineReceiver):
    """
    A Twisted IProtocol to read PT output.

    See pt-spec.txt and others for details of the protocol.
    """
    # TODO(infinity0): eventually this could be padded out and moved to pyptlib

    delimiter = os.linesep
    protocol_version = "1"

    def __init__(self):
        self.cmethods = {}
        self._dCMethodsDone = Deferred()
        self._dPluginError = Deferred()
        # dPluginError triggers errors on all sub-events, not the other way round
        # so fatal sub-events should call _abort rather than errback on their Deferreds
        self._dPluginError.addErrback(lambda f: (f, self._fireCMethodsDone().errback(f))[0])
        # TODO(infinity0): call _abort if we don't recv CMETHODS DONE within n sec

    def whenCMethodsDone(self):
        """
        Return a new Deferred that calls-back when CMETHODS DONE is received.
        """
        return branch(self._dCMethodsDone)

    def whenPluginError(self):
        """
        Return a new Deferred that errors-back when the remote plugin fails.

        Note: the success chain (callback) is never fired.
        """
        return branch(self._dPluginError)

    def lineReceived(self, line):
        if not line: return

        (kw, args) = line.split(' ', 1)
        if kw == "VERSION":
            version = args.strip()
            if version != self.protocol_version:
                self._abort(ValueError("child used unsupported managed transport version: %s" % version))
        elif kw == "CMETHOD":
            cmethod = MethodSpec.fromLine(args)
            self.cmethods[cmethod.name] = cmethod
        elif kw == "CMETHODS" and args == "DONE":
            self._fireCMethodsDone().callback(self.cmethods)
        else:
            pass # ignore unrecognised line

    def connectionLost(self, reason=connectionDone):
        self._firePluginError().errback(reason)

    def _abort(self, exc):
        self._firePluginError().errback(exc)
        self.transport.loseConnection()

    def _fireCMethodsDone(self):
        """Return dCMethodsDone or a dummy if it was already called."""
        if self._dCMethodsDone:
            d = self._dCMethodsDone
            self._dCMethodsDone = None
            return d
        return Deferred().addErrback(lambda *args: None)

    def _firePluginError(self):
        """Return dPluginError or a dummy if it was already called."""
        if self._dPluginError:
            d = self._dPluginError
            self._dPluginError = None
            return d
        return Deferred().addErrback(lambda *args: None)

# TODO(infinity0): remove this class when twisted update their side
class ProxyServer(_ProxyServer):

    def connectionMade(self):
        # code copied from super class, except instead of connecting
        # to a TCP endpoint we abstract that out to a child method
        self.transport.pauseProducing()

        client = self.clientProtocolFactory()
        client.setServer(self)

        if self.reactor is None:
            from twisted.internet import reactor
            self.reactor = reactor

        self.connectProxyClient(client)

    def connectProxyClient(self, client):
        raise NotImplementedError()

class OneUseSOCKS4Wrapper(ProxyServer):

    def connectProxyClient(self, client):
        TCPPoint = TCP4ClientEndpoint(
            self.reactor,
            self.factory.local_host,
            self.factory.local_port)
        SOCKSPoint = SOCKS4ClientEndpoint(
            self.factory.remote_host,
            self.factory.remote_port,
            TCPPoint)
        # Store port for debugging messages before stopListening is called. listen_port will not have a port after stopListening is called.
        stored_port = self.factory.listen_port.getHost().port
        d_port_closed = self.factory.listen_port.stopListening()
        d_port_closed.addCallback(
            lambda x: logger.debug("Closed factory listener %s on port %s" % (self.factory, stored_port)))
        d_port_closed.addErrback(
            lambda x: logger.warn("Failed to close factory listener %s listening on port %s" % (self.factory, stored_port)))
        d = SOCKSPoint.connect(client)
        d.chainDeferred(self.factory.d_connected)
        @d.addErrback
        def _gotError(error):
            log.err(error, "error connecting to SOCKS server")

class OneUseSOCKS4Factory(Factory):
    protocol = OneUseSOCKS4Wrapper

    def __init__(self, local_host, local_port, remote_host, remote_port):
        self._connected_once = False
        self.local_host = local_host
        self.local_port = local_port
        self.remote_host = remote_host
        self.remote_port = remote_port
        self.d_connected = Deferred()
        self.listen_port = None

    def __str__(self):
        return "OneUseSOCKS4Factory connecting %s:%s to %s:%s" % (self.local_host, self.local_port, self.remote_host, self.remote_port)

    def __repr__(self):
        return "OneUseSOCKS4Factory(%s, %s, %s, %s)" % (self.local_host, self.local_port, self.remote_host, self.remote_port)

    def setListenPort(self, listen_port):
        """
        Sets the listen_port object.
        :param function listen_port: The function returned from a ListenTCP call. Used to shutdown the port when a connection is made.
        """
        self.listen_port = listen_port

    def whenConnected(self):
        """
        Returns a new Deferred that triggers when a connection is successfully made.
        """
        return branch(self.d_connected)

    def buildProtocol(self, addr):
        """
        Only allows one protocol to be created. After that it always returns None
        :param twisted.internet.interfaces.IAddress addr: an object implementing L{twisted.internet.interfaces.IAddress}
        """
        if self._connected_once:
            return None
        else:
            self._connected_once = True
            return Factory.buildProtocol(self, addr)

if sys.platform == "win32":
    # TODO(infinity0): push this upstream to Twisted
    from twisted.internet import _pollingfile
    import msvcrt

    _StandardIO = StandardIO
    class StandardIO(_StandardIO):

        def __init__(self, proto, stdin=None, stdout=None, reactor=None):
            """
            Start talking to standard IO with the given protocol.

            Also, put it stdin/stdout/stderr into binary mode.
            """
            if reactor is None:
                import twisted.internet.reactor
                reactor = twisted.internet.reactor

            _pollingfile._PollingTimer.__init__(self, reactor)
            self.proto = proto

            fdstdin = stdin or sys.stdin.fileno()
            fdstdout = stdout or sys.stdout.fileno()

            for stdfd in (fdstdin, fdstdout):
                msvcrt.setmode(stdfd, os.O_BINARY)

            hstdin = msvcrt.get_osfhandle(fdstdin)
            self.stdin = _pollingfile._PollableReadPipe(
                hstdin, self.dataReceived, self.readConnectionLost)

            hstdout = msvcrt.get_osfhandle(fdstdout)
            self.stdout = _pollingfile._PollableWritePipe(
                hstdout, self.writeConnectionLost)

            self._addPollableResource(self.stdin)
            self._addPollableResource(self.stdout)

            self.proto.makeConnection(self)

def pt_launch_child(reactor, client, methodnames, pt_method_name, cmdline):
    """Launch a child PT and ensure it has the right transport methods."""
    cur_env = pt_child_env(ManagedTransportProtocolV1.protocol_version)
    environment = dict(cur_env + {
            "TOR_PT_CLIENT_TRANSPORTS": ",".join(methodnames),
        }.items())
    sub_proc = Popen(cmdline,
        stdout = PIPE,
        env = environment,
        )
    sub_protocol = ManagedTransportProtocolV1()
    # we ought to pass reactor=reactor in below, but this breaks Twisted 12
    StandardIO(sub_protocol, stdin=sub_proc.stdout.fileno())
    methoddefers = [sub_protocol.whenCMethodsDone().addCallback(
                        partial(pt_require_child, client, name, pt_method_name))
                    for name in methodnames]
    return sub_proc, sub_protocol, methoddefers

def pt_require_child(client, childmethod, pt_method_name, cmethods):
    """Callback for checking a child PT has the right transport methods."""
    if childmethod not in cmethods:
        client.reportMethodError(pt_method_name, "failed to start required child transport: %s" % childmethod)
        raise ValueError()
    return cmethods[childmethod]

def pt_setup_socks_shim(pt_name, pt_chain, success_list, dest_address, dest_port, reactor, proxy_deferreds):
    """
    Launches a socks proxy server to link two PTs together.
    :param str pt_name: The name of the pt to send traffic to.
    :param list pt_chain: The list of PTs in this chain.
    :param list success_list: A list of tuples containing a launch status boolean, MethodSpec pairs.
        Ex: [(True, MethodSpec(name='dummy', protocol='socks4', addrport=('127.0.0.1', 58982), args=[], opts=[])),
            (True, MethodSpec(name='b64', protocol='socks4', addrport=('127.0.0.1', 58981), args=[], opts=[]))]
    :param str dest_address: The address for the next PT to send its results to.
    :param int dest_port: The port for the next PT to send to.
    :param twisted.internet.interfaces.IReactor reactor: Reactor to attack the TCP server to.

    :param list proxy_deferreds: This list has each factorys' deferred appended to it.

    :returns twisted.internet.interfaces.IListeningPort: An IListeningPort used for shutting down a factory after a connection is made.
    """
    methodspec = [r[1] for r in success_list if r[1].name == pt_name][0] # Returns the resulting methodspec.
    factory = OneUseSOCKS4Factory(methodspec.addrport[0], methodspec.addrport[1], dest_address, dest_port)
    # TODO switch to using endpoints instead of listenTCP
    proxy_server = reactor.listenTCP(interface='127.0.0.1', port=0, factory=factory)
    factory.setListenPort(proxy_server)
    proxy_deferreds.append(factory.whenConnected())
    logger.debug("launched %s on port %s with dest %s:%s" % (pt_name, proxy_server.getHost().port, dest_address, dest_port))
    return proxy_server

def pt_launch_chain(dest_address, dest_port, pt_chain, _chain_set_up, reactor, success_list):
    """
    Launches a chain of pluggable transports by connecting each pt with SOCKS proxies.
    :param str dest_address: The bridge address to connect to.
    :param int dest_port: The bridge port to connect to.
    :param list pt_chain: The list of pt names to launch.
    :param function _chain_set_up: The function to call when the shims have been set up.
    :param twisted.internet.interfaces.IReactor reactor: Reactor to install this PT to.
    :param list success_list: A list of tuples containing a launch status boolean, MethodSpec pairs.
        Ex: [(True, MethodSpec(name='dummy', protocol='socks4', addrport=('127.0.0.1', 58982), args=[], opts=[])),
            (True, MethodSpec(name='b64', protocol='socks4', addrport=('127.0.0.1', 58981), args=[], opts=[]))]
    """
    proxy_deferreds = []
    last_pt_name = pt_chain[-1]
    logger.debug("launching chain %s" % pt_chain)
    # Initialize prev_server to the port picked by the last proxy server as that's the only one we know yet.
    last_server = pt_setup_socks_shim(last_pt_name, pt_chain, success_list, dest_address, dest_port,
                                    reactor, proxy_deferreds)
    prev_server = last_server
    for pt_name in reversed(pt_chain[:-1]):
        # Loops through the pts linking them together through SOCKS proxies, skipping the last pt.
        prev_server = pt_setup_socks_shim(pt_name, pt_chain, success_list, '127.0.0.1', prev_server.getHost().port,
                                        reactor, proxy_deferreds)
    def check_chain_all_connected(protocol_list):
        """
        Checks all the shims launched to see if they successfully connected.
        :param list protocol_list: A list of tuples containing status boolean, twisted.protocols.portforward.ProxyClient pairs.
            Ex: [(True, <twisted.protocols.portforward.ProxyClient instance at 0x10b825518>),
                 (True, <twisted.protocols.portforward.ProxyClient instance at 0x10b829518>)]
        """
        if all([result[0] for result in protocol_list]):
            logger.debug("All PT shims connected correctly")
        else:
            # At this point the SOCKS protocol is in communication mode so no need to call makeReply(91)
            # This assumes that the child pluggable transport will shut down the connection cleanly.
            failed_protocols = [x[1] for x in protocol_list if x[0] == False]
            logger.error("Shims %s failed to connect." % failed_protocols)
            raise ValueError()

    finished = DeferredList(proxy_deferreds)
    finished.addCallback(check_chain_all_connected)
    _chain_set_up(prev_server.getHost().host, prev_server.getHost().port)

def pt_launch_interceptor(reactor, client, configuration, pt_method_name, success_list):
    """
    Launches a SOCKS interceptor.
    :param twisted.internet.interfaces.IReactor reactor: Reactor to install this PT to.
    :param pyptlib.client.ClientTransportPlugin client: PT client API.
    :param Config configuration: The configuration structure for this pair.
    :param str pt_method_name: The name of the pt chain to launch. Ex: "obfs3_flashproxy"
    :param list success_list: A list of tuples containing a launch status boolean, MethodSpec pairs.
        Ex: [(True, MethodSpec(name='dummy', protocol='socks4', addrport=('127.0.0.1', 58982), args=[], opts=[])),
            (True, MethodSpec(name='b64', protocol='socks4', addrport=('127.0.0.1', 58981), args=[], opts=[]))]
    """
    logger.debug("launching interceptor")
    pt_chain = configuration.alias_map[pt_method_name]
    success = all(r[0] for r in success_list if r[1].name in pt_chain)
    # failure was already reported by pt_require_child, just return
    if not success: return
    socks_interceptor = SOCKSv4InterceptorFactory(pt_method_name,
                        lambda dest_address, dest_port, pt_method_name, chain_finished:
                            pt_launch_chain(dest_address, dest_port, pt_chain, chain_finished, reactor, success_list))
    # TODO switch to using endpoints instead of listenTCP
    interceptor = reactor.listenTCP(interface='127.0.0.1', port=0, factory=socks_interceptor)
    interceptor_port = interceptor.getHost().port
    client.reportMethodSuccess(pt_method_name, "socks4", ("127.0.0.1", interceptor_port))
    client.reportMethodsEnd()

def pt_setup_transports(reactor, client, configuration, pt_method_name):
    """
    Launches the PT processes.
    :param twisted.internet.interfaces.IReactor reactor: Reactor to install this PT to.
    :param pyptlib.client.ClientTransportPlugin client: PT client API.
    :param Config configuration: The configuration structure for this pair.
    :param str pt_method_name: The name of the pt chain to launch. Ex: "obfs3_flashproxy"
    """
    logger.debug("Setting up transports %s" % pt_method_name)
    if pt_method_name in configuration.alias_map:
        pt_chain = configuration.alias_map[pt_method_name]
    else:
        logger.error('Pluggable Transport Combination %s not found in configuration alias map.' % pt_method_name)
        raise KeyError()

    defer_list = []

    if len(pt_chain) < 2:
        raise ValueError("PT Chain %s does not contain enough transports." % pt_chain)

    for pt in pt_chain:
        if pt in configuration.transport_map:
            pt_cmdline = configuration.transport_map[pt]
        else:
            raise ValueError("Pluggable transport %s not found in transport_map. Check your configuration file." % pt)
        _, _, defer = pt_launch_child(reactor, client, [pt], pt_method_name, pt_cmdline)
        defer_list.extend(defer)
    whenAllDone = DeferredList(defer_list, consumeErrors=False)
    whenAllDone.addCallback(lambda success_list: pt_launch_interceptor(reactor, client, configuration, pt_method_name, success_list))


class Config():
    # Transport map links a pluggable transport name to the a commandline to launch it.
    # Ex: {'b64' : 'exec obfsproxy managed'}
    transport_map = None

    #Alias map links a pluggable transport chain name to a list of individual pluggable transports
    # Ex: {'dummy_b64_dummy2' : ['dummy''b64''dummy2']}
    alias_map = None

    def __init__(self, transport_map, alias_map):
        self.transport_map = transport_map
        self.alias_map = alias_map

    def __repr__(self):
        return "Config(%s, %s)" % (self.transport_map, self.alias_map)

    def __str__(self):
        return "Config Object with transport_map: %s, and alias_map %s." % (self.transport_map, self.alias_map)

    @classmethod
    def parse(cls, config_string):
        """
        Reads a configuration string and returns an instance of configuration. Uses shlex to parse configuration lines.
        :param str config_string: The string which will be parsed to populate the transport_map and alias_map hash tables.
        See the file example-fog-config for format.
        """
        # TODO Add possibility of reading a ClientTransportPlugin with multiple transport types
        # Ex: ClientTransportPlugin obfs3,scramblesuit obfsclient --option=value

        line_counter = 0
        lines = config_string.split('\n')
        transport_map = {}
        alias_map = {}

        for line in lines:
            line_counter += 1
            if len(line) > 0 and line[0] != '#' : # Check for empty lines and comment tags on the first
                line = line.strip()
                delimited_tokens = shlex.split(line)
                if len(delimited_tokens) > 1:
                    config_line_type = delimited_tokens[0] # This can be either Alias or ClientTransportPlugin
                    if config_line_type == 'ClientTransportPlugin':
                        cls.parse_transport_line(transport_map, delimited_tokens, line_counter)
                    elif config_line_type == 'Alias':
                        cls.parse_alias_line(alias_map, transport_map, delimited_tokens, line_counter)
                    else:
                        logger.warn("Configuration file has unknown line %s: '%s'" % (line_counter, line))
        return cls(transport_map, alias_map)

    @classmethod
    def parse_transport_line(cls, transport_map, delimited_tokens, line_counter):
        transport_name = delimited_tokens[1]
        transport_cmdline = delimited_tokens[2:]
        if transport_name in transport_map:
            raise ValueError('Configuration file has duplicate ClientTransportPlugin lines. Duplicate line is at line number %s' % line_counter)
        transport_map[transport_name] = transport_cmdline

    @classmethod
    def parse_alias_line(cls, alias_map, transport_map, delimited_tokens, line_counter):
        alias_name = delimited_tokens[1] # Example: "obfs3_flashproxy"
        alias_path = delimited_tokens[2].split('|') # Example: "obfs3|flashproxy"
        if alias_name in alias_map:
            raise ValueError('Configuration file has duplicate Alias lines. Duplicate line is at line number %s' % line_counter)
        for pt_name in alias_path:
            if pt_name not in transport_map:
                raise KeyError('Transport map is missing pluggable transport %s needed for chain %s. Check your configuration file for a ClientTransportPlugin line can launch %s' % (pt_name, alias_name, pt_name))
        alias_map[alias_name] = alias_path

def obfs3_flashproxy(fp_remote, fp_args=[], fp_local=0):
    """
    Set up the obfs3_flashproxy combined PT.
    :param str fp_remote: Listen address for remote flashproxy connections.
    :param str fp_args: The arguments to pass to the flashproxy connections.
    :param int fp_local: Local listen port for local flashproxy connections.
    """
    ob_client = os.getenv("OBFSPROXY", "obfsproxy")
    fp_client = os.getenv("FLASHPROXY_CLIENT", "flashproxy-client")

    fp_cmdline =  [fp_client, "--transport", 'obfs3|websocket'] + fp_args + ['127.0.0.1:%s' % fp_local, fp_remote]
    obfs_cmd_line = [ob_client, "managed"]

    transport_map = {'obfs3': obfs_cmd_line, 'flashproxy': fp_cmdline}
    alias_map = {'obfs3_flashproxy': ['obfs3', 'flashproxy']}

    configuration = Config(transport_map, alias_map)
    return configuration

def main(*args):
    parser = argparse.ArgumentParser()
    parser.add_argument("fp_remote", help="remote connections listen address "
        "for flashproxy, default %(default)s",
        metavar='REMOTE:PORT', nargs='?', default=":9000")
    parser.add_argument("--fp-arg", help="arguments for flashproxy-client",
        metavar='ARG', action='append')
    parser.add_argument("-f", help="fog configuration file path",
        metavar='FOGFILE', type=argparse.FileType('r'))

    pt_setup_logger()
    # TODO(infinity0): add an "external" mode, which would require us to run
    # obfsproxy in external mode too.

    opts = parser.parse_args(args)

    # ensure string address is valid
    _, _, = parse_addr_spec(opts.fp_remote, defhost="0.0.0.0")
    configuration = None

    if opts.f:
        file_contents = opts.f.read()
        configuration = Config.parse(file_contents)
        pt_method_names = configuration.alias_map.keys()
    else:
        pt_method_names = ["obfs3_flashproxy"]
        configuration = obfs3_flashproxy(opts.fp_remote, opts.fp_arg or [])
    client = ClientTransportPlugin()
    client.init(pt_method_names) # Initialize our possible methods to all the chains listed by the fog file and stored in alias map.
    if not client.getTransports():
        logger.error("no transports to serve. pt_method_names may be invalid.")
        return 1

    from twisted.internet import reactor
    auto_killall(1, cleanup=reactor.stop)
    #TODO Change from launching a single pair to launching multiple chains.
    pt_setup_transports(reactor, client, configuration, pt_method_names[0])
    reactor.run(installSignalHandlers=0)
    return 0

if __name__ == "__main__":
    sys.exit(main(*sys.argv[1:]))

